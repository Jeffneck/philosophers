dead lock : accessible a tous les philos, donc mutex 
write lock :  





PHILO lOOP
un philo loop tant que end_simulation est false
un philo eat tant qu' il n' est pas full un philo full va modifier la variable nb_philo_full(mutex) puis alterner entre sleep et think
un philo mort va modifier la variable death_detected

MONITORING LOOP
if death_detected == 1 || nb_philos_full == nb_philos 
	end_simulation = 1;

GESTION END SIMULATION
avant chaque ecriture de philo, verifier if (end_simulation == false)


on cree tous les mutex , Si err appel a destroy_all_mutex
on cree tous les threads philos,

routine_philo va alterner, eat, sleep, think...


que se passe t il 

	if (pair)
	{
		philo->first_fork = &(forks[philo->id % philo->rules->philos_nbr]);
		philo->second_fork = &(forks[philo->id - 1]);
	}
	else
	{
		philo->first_fork = &(forks[philo->id - 1]);
		philo->second_fork = &(forks[philo->id]);
	}

1 = 0/1
2 = 2/1
3 = 2/3
4 = 4/3
5 = 4/5
6 = 6/5
7 = 0/6

1vs7 2vs3 4vs5 6 => 1 2 6

